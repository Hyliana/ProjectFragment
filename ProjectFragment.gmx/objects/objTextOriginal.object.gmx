<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>justDelayed=false;
postDelayChar=""
skipPipe=false;
curDrawChar="";
col=c_white;
delayIndexChanged=false;
tmpStepDelay=5;
escape=false;
debugChar="";
global.curview=0;
intentionalDelay=false;
myNumber=0;
line[0]="";
lineCount=0;
curline=0;
buffer=32;
curString="";
instaNewLineCount=0;
index=0;
canFire=false;
fireNow=false;
stepDelay=3;
delayIndex=0
maxStringWidth = room_width-(buffer*2);
alarm[0] = 10; //Set up the event to create the variables that matter
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>numOfChars = string_length(lineOfText);
lineCount=string_width(lineOfText)/(maxStringWidth)+1;
instaNewLineCount= string_count("|n", lineOfText);
for(cr=0; cr&lt;lineCount+instaNewLineCount; cr++){
line[cr]="";
}

curLine=0;
canFire=true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(canFire){
if(index&lt;numOfChars)
{
    //if(control(global.SPEED_UP_TEXT))
    {
    
    }
{
    if(!delayIndexChanged){
        if(delayIndex&gt;=stepDelay)
        {   
            delayIndex=0;
            fireNow=true;
        }
        else
        {
            if(!intentionalDelay)
            {
                delayIndex+=1;
            }
            else
            {
                if(idelayCount==1){
                intentionalDelay=false;
                }
                idelayCount-=1;
            }
        }
    }
    else if(delayIndexChanged){
        if(delayIndex&gt;=tmpStepDelay)
        {   
            delayIndex=0;
            fireNow=true;
        }
        else
        {
            if(!intentionalDelay)
            {
                delayIndex+=1;
            }
            else
            {
                if(idelayCount==1){
                intentionalDelay=false;
                }
                idelayCount-=1;
            }
        }
    }
    
    if(fireNow)
    {
        
        if(string_ord_at(lineOfText, index) == ord('|'))
        {
            escape=true;
            index++;
            
            if(string_ord_at(lineOfText, index) == ord('n')) //Newline char
            {
                debugChar="n";
                index++;
                curLine+=1;
            }
            else if(string_ord_at(lineOfText, index) == ord('c')) //Changes Color of text. Semifunctional.
            {
                debugChar="c";
                testIndex=1;
                colString="";
                while(string_ord_at(lineOfText, index+testIndex) != ord('_')){
                    colString=(colString+string_char_at(lineOfText, index+testIndex));
                    testIndex+=1;
                }
                switch(colString){
                    case "red":
                    col=c_red
                    break;
                    
                    case "green":
                    col=c_green
                    break;
                    
                    case "blue":
                    col=c_blue
                    break;
                    
                    case "yellow":
                    col=c_yellow
                    break;
                }
                index+=testIndex;
            }
            else if(string_ord_at(lineOfText, index) == ord('d')) // Adds delay to writing.
            {
                index++;
                debugChar="d";
                intentionalDelay=true;
                testIndex=0;
                waitTicksString="";
                while(string_ord_at(lineOfText, index+testIndex) != ord('_')){
                    waitTicksString=(waitTicksString+string_char_at(lineOfText, index+testIndex));
                    testIndex++;
                }
                idelayCount = real(string_digits(waitTicksString));
                index+=(testIndex+1);
                postDelayChar=string_char_at(lineOfText, index);
                justDelayed=true;
            }
            else if(string_ord_at(lineOfText, index) == ord('s')) // Speed of textbox. Changes tmpStepDelay
            {
                debugChar="s";
                delayIndexChanged=true;
                testIndex=1;
                waitTicksString="";
                while(string_ord_at(lineOfText, index+testIndex) != ord('_')){
                    waitTicksString=(waitTicksString+string_char_at(lineOfText, index+testIndex));
                    testIndex+=1;
                }
                tmpStepDelay = real(string_digits(waitTicksString));
                index+=testIndex;
            }
            else if(string_ord_at(lineOfText, index) == ord('r'))
            {
                debugChar="r";
                delayIndexChanged=false;
            }
            else if(string_ord_at(lineOfText, index) == ord('w'))
            {
                debugChar="w";
                col=c_white;
            }
            escape=false;
        }
        else if(string_ord_at(lineOfText, index) != ord(' ')){
            sound_play(sndTick);
            index++; ////////////////// INDEX++ //////////////////
            if(!justDelayed)
                line[curLine]=line[curLine]+string_char_at(lineOfText, index);
            else
            {
                line[curLine]=line[curLine]+postDelayChar;
                justDelayed=false;    
            }
            canBreak=false;
            
        }
        else if(string_ord_at(lineOfText, index) == ord(' '))
        {
            nextWordCounter=1;
            testingWidth=0;
            testingString=line[curline];
            while(string_char_at(lineOfText, index+nextWordCounter) != (' ') &amp;&amp; string_ord_at(lineOfText, index+nextWordCounter) != ord('|'))
            {
                nextWordCounter+=1; 
                testingString+=string_char_at(testingString, nextWordCounter);
                testingWidth=string_width(testingString)
            }
            
            if(testingWidth&gt;(maxStringWidth)){
                curLine+=1;
                lineCount++;
                line[lineCount+instaNewLineCount]="";
            }
            else{
                index++;  ////////////////// INDEX++ //////////////////
                if(!justDelayed)
                    line[curLine]=line[curLine]+string_char_at(lineOfText, index);
                else
                {
                    line[curLine]=line[curLine]+postDelayChar;
                    justDelayed=false;    
                }
                
            }
        }
        
        
        fireNow=false;    
    }
    
    if(string_width(line[curLine])&gt;maxStringWidth){
        if(canBreak){
            curLine+=1;
            canBreak=false;
        }
    }
}
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(textbox);
    
    

//draw_text(12,40,

    
//CENTERED
/*
for(nol = 0; nol&lt;lineCount+1; nol+=1)
{
    draw_set_color(col);
    draw_text(room_width/2-(string_width(line[nol])/2)+2,32+2+((string_height(line[nol])+16)*nol), line[nol]);
    
    lineDrawn=false;
    lineLength=string_length(line[nol]);
    charX=buffer;
    charIndex=1;
    realIndex=charIndex*nol;
    
    while(charIndex&lt;lineLength){   
        draw_set_color(col);
        draw_text(charX, 32+((string_height(line[nol])+16)*nol), string_char_at(line[nol], charIndex));
        charX+=string_width(string_char_at(line[nol], charIndex));
        charIndex++;
        }
}
*/

//LEFT
for(nol = 0; nol&lt;lineCount+instaNewLineCount; nol+=1)
{
    //draw_set_color(c_olive);
    //draw_text(buffer+2,32+2+((string_height(line[nol])+16)*nol), line[nol]);
    lineDrawn=false;
    lineLength=string_length(line[nol]);
    charX=buffer;
    charIndex=1;
    
    while(charIndex&lt;lineLength){   
        draw_set_color(col);
        draw_text(charX, 64+((string_height(line[nol])+16)*nol), string_char_at(line[nol], charIndex));
        charX+=string_width(string_char_at(line[nol], charIndex));
        curDrawChar=string_char_at(line[nol], charIndex);
        charIndex++;
        }
    
    
//    draw_text(buffer,32+((string_height(line[nol])+16)*nol), line[nol]);
}

if(skipPipe)
draw_text(12,12,"skipping pipe");
draw_text(12,12,debugChar);
draw_text(12,22,string(index));
draw_text(12,32,"iChar:"+string_char_at(lineOfText, index));
draw_text(12,42,"drawn:"+curDrawChar);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
