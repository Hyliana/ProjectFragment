<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//BOOLEANS//
done=false;
choiceImpending=false;
justDelayed=false;
skipPipe=false;
delayIndexChanged=false;
escape=false;
intentionalDelay=false;
canFire=false;
fireNow=false;

//STRINGS//
curString="";
postDelayChar=""
curDrawChar="";
line[0]="";
debugChar="";
nextWord="";

//COLORS//
col=c_white;

//FONTS//
thisBoxFont = textbox;

//NUMERIC VALUES
tmpStepDelay=5;
initHeight=32;
vSpace=string_height("|")+12;
instaNewLineCount=0;
index=0;
myNumber=0;
lineCount=0;
curLine=0;
buffer=24;
stepDelay=3;
delayIndex=0;
maxStringWidth = room_width-(buffer*2);
dialogueGoto=0; //When a choice is made, this variable tells the game what dialogue box to go to.

//OBJECT VARIABLES
q=0;     //q is a reference to the currently active question object.

//Set up the event to create the variables that matter
alarm[0] = 1; 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>numOfChars = string_length(lineOfText);
lineCount=string_width(lineOfText)/(maxStringWidth);
instaNewLineCount= string_count("|n", lineOfText);
for(cr=0; cr&lt;lineCount+instaNewLineCount; cr++){
line[cr]="";
}

curLine=0;
canFire=true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(canFire){
if(index&lt;numOfChars)
{
{
    if(!delayIndexChanged){
        if(control(global.SPEED_UP_TEXT))
        {
            delayIndex=stepDelay;
        }
        if(delayIndex&gt;=stepDelay)
        {   
            delayIndex=0;
            fireNow=true;
        }
        else
        {
            if(!intentionalDelay)
            {
                delayIndex+=1;
            }
            else
            {
                if(idelayCount==1){
                intentionalDelay=false;
                }
                idelayCount-=1;
            }
        }
    }
    else if(delayIndexChanged){
        if(delayIndex&gt;=tmpStepDelay)
        {   
            delayIndex=0;
            fireNow=true;
        }
        else
        {
            if(!intentionalDelay)
            {
                delayIndex+=1;
            }
            else
            {
                if(idelayCount&lt;=1){
                intentionalDelay=false;
                }
                if(!control(global.SPEED_UP_TEXT))
                {
                    idelayCount-=1;
                }
                else
                {
                    idelayCount-=2;
                }
                
            }
        }
    }
    
    if(fireNow)
    {
        
        if(string_ord_at(lineOfText, index) == ord('|')) //Esacape Character. Need to figure out how to check BEFORE adding.
        {
            escape=true;
            index++;
            
            //TEXT ACTION ESC CHARS/////////////////////////////////////////////////////////////////////////////////
            if(string_ord_at(lineOfText, index) == ord('A')) //ARBITER ONLY - Choose where to see next.
            {
                done=true;
                choiceImpending=true;
                global.questionID=0;
                canFire=false;
                event_perform(ev_other, ev_user0);
                index++;
            }
            else if(string_ord_at(lineOfText, index) == ord('E')) //If the signal is given to end the current textbox...
            {
                done=true;
                choiceImpending=false;
                canFire=false;
                index++;
            }
            else if(string_ord_at(lineOfText, index) == ord('Q')) //If the signal is given to provide a choice...
            {
                done=true;
                choiceImpending=true;
                canFire=false;
                event_perform(ev_other, ev_user0);
                index++;
            }
            else if(string_ord_at(lineOfText, index) == ord('X')) //If the signal is given to end the game prematurely...
            {
                event_perform(ev_other, ev_user15);
            }
            
            
            //TEXT MODIFICATION ESC CHARS/////////////////////////////////////////////////////////////////////////////////
            else if(string_ord_at(lineOfText, index) == ord('n')) //Newline char
            {
                debugChar="n";
                index++;
                curLine+=1;
            }
            else if(string_ord_at(lineOfText, index) == ord('c')) //Changes Color of text. Semifunctional.
            {
                debugChar="c";
                testIndex=1;
                colString="";
                while(string_ord_at(lineOfText, index+testIndex) != ord('_')){
                    colString=(colString+string_char_at(lineOfText, index+testIndex));
                    testIndex+=1;
                }
                switch(colString){
                    case "red":
                    col=c_red
                    break;
                    
                    case "green":
                    col=c_green
                    break;
                    
                    case "blue":
                    col=c_blue
                    break;
                    
                    case "yellow":
                    col=c_yellow
                    break;
                }
                index+=(testIndex+1);
            }
            else if(string_ord_at(lineOfText, index) == ord('d')) // Adds delay to writing.
            {
                index++;
                debugChar="d";
                intentionalDelay=true;
                testIndex=0;
                waitTicksString="";
                while(string_ord_at(lineOfText, index+testIndex) != ord('_')){
                    waitTicksString=(waitTicksString+string_char_at(lineOfText, index+testIndex));
                    testIndex++;
                }
                idelayCount = real(string_digits(waitTicksString));
                index+=(testIndex+1);
                postDelayChar=string_char_at(lineOfText, index);
                justDelayed=true;
            }
            else if(string_ord_at(lineOfText, index) == ord('s')) // Speed of textbox. Changes tmpStepDelay
            {
                debugChar="s";
                delayIndexChanged=true;
                testIndex=1;
                waitTicksString="";
                while(string_ord_at(lineOfText, index+testIndex) != ord('_')){
                    waitTicksString=(waitTicksString+string_char_at(lineOfText, index+testIndex));
                    testIndex+=1;
                }
                tmpStepDelay = real(string_digits(waitTicksString));
                index+=(testIndex+1);
            }
            else if(string_ord_at(lineOfText, index) == ord('m')) // ONLY FOR USE WITH ARBITER! - Changes prologueObject.em_index
            {
                debugChar="m";
                testIndex=1;
                emString="";
                while(string_ord_at(lineOfText, index+testIndex) != ord('_')){
                    emString=(emString+string_char_at(lineOfText, index+testIndex));
                    testIndex+=1;
                }
                prologueObject.em_index = real(string_digits(emString));
                index+=(testIndex+1);
            }
            else if(string_ord_at(lineOfText, index) == ord('r'))
            {
                debugChar="r";
                delayIndexChanged=false;
                index++;
            }
            else if(string_ord_at(lineOfText, index) == ord('w'))
            {
                debugChar="w";
                col=c_white;
                index++;
            }
            
            else if(string_ord_at(lineOfText, index) == ord('v')) // ONLY FOR USE WITH ARBITER! - Changes prologueObject.em_index
            {
                debugChar="v";
                testIndex=1;
                emString="";
                while(string_ord_at(lineOfText, index+testIndex) != ord('_')){
                    emString=(emString+string_char_at(lineOfText, index+testIndex));
                    testIndex+=1;
                }
                global.speakingPersona = real(string_digits(emString));
                index+=(testIndex+1);
            }
            escape=false;
        }
        else if(string_ord_at(lineOfText, index) != ord(' ')){
            playDialogSound();
            
            if(!justDelayed)
                line[curLine]=line[curLine]+string_char_at(lineOfText, index);
            else
            {
                line[curLine]=line[curLine]+postDelayChar;
                justDelayed=false;    
            }
            canBreak=false;
            index++; ////////////////// INDEX++ //////////////////
        }
        else if(string_ord_at(lineOfText, index) == ord(' '))
        {
            nextWord="";
            nextWordCounter=1;
            testingWidth=0;
            testingString=line[curLine];
            
            if(!escape &amp;&amp; string_ord_at(lineOfText, index+nextWordCounter) != ord('|'))
            while(string_ord_at(lineOfText, index+nextWordCounter) != ord(' '))
            {
                nextWord=nextWord+string_char_at(lineOfText, index+nextWordCounter);
                nextWordCounter+=1;
            }
            testingWidth=string_width(testingString+" "+nextWord);
            
            if(testingWidth&gt;=(maxStringWidth))
            {
                line[curLine+1]=string_char_at(lineOfText, index);
                curLine++;
                index++;
            }
            else{
                
                if(!justDelayed)
                    line[curLine]=line[curLine]+string_char_at(lineOfText, index);
                else
                {
                    line[curLine]=line[curLine]+postDelayChar;
                    justDelayed=false;    
                }
                index++;  ////////////////// INDEX++ //////////////////
            }
        }
        
        
        fireNow=false;    
    }
    
    if(string_width(line[curLine])&gt;maxStringWidth){
        if(canBreak){
            curLine+=1;
            canBreak=false;
        }
    }
}
}
}
else if(done &amp;&amp; !choiceImpending)
{
    if(control(global.NEXT_BOX))
    {
        global.dBox++;
        global.createBox=true;
        sound_play(sndNextDialogue);
        instance_destroy();
    }
}
else if(done &amp;&amp; choiceImpending)
{
    if(controlPressed(global.DOWN))
    {
        if(q.curSel&lt;2)    
        {
            q.curSel++;
            sound_play(sndMoveChoiceArrow);
        }
    }
    if(controlPressed(global.UP))
    {
        if(q.curSel&gt;0)    
        {
            q.curSel--;
            sound_play(sndMoveChoiceArrow);            
        }
    }
    if(control(global.NEXT_BOX))
    {
        event_perform(ev_other,ev_user1);
        global.dBox=dialogueGoto;
        global.createBox=true;
        sound_play(sndNextDialogue)
        with q instance_destroy();
        instance_destroy();
    }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(global.questionID){
        case 0:           ////////////////////  Question 0 - What land to view  //
        {
            pcFlags.landChosen=true;
            switch(q.curSel)
            {
                case 0:
                if(!pcFlags.witherFinished)
                {
                    pcFlags.landChosenWither=true;
                    dialogueGoto=7;
                }
                else if(pcFlags.witherFinished)
                {
                    dialogueGoto=121+global.witherTryCount;
                    global.witherTryCount++;
                }
                break;
                
                case 1:
                pcFlags.landChosenScourge=true;
                break;
                
                case 2:
                pcFlags.landChosenScorch=true;
                break;
            }
        }break;
        
        case 1:           ////////////////////  Question ID 1 - Wither Options 1 //                    
        {
            pcFlags.witherFinished=true;
            
            switch(q.curSel)
            {
                case 0:
                pcFlags.lcwQ1=true;
                dialogueGoto=13;
                break;
                
                case 1:
                pcFlags.lcwQ2=true;
                dialogueGoto=15;
                break;
                
                case 2:
                pcFlags.lcwQ3=true;
                dialogueGoto=17;
                break;
            }
        }break;
        
        default: show_message("global.questionID is invalid/not accounted for in ev_user1!");
        break;
}
        
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>q.curSel=0;
if(room==roomArbiterWelcome)
{
    if(!pcFlags.landChosen)
    {
        global.questionID=0; //Question ID - "What land do you want to see?"
        createArbiterQuestion(3,"Witness the WITHER","Behold the SCOURGE","See the SCORCH");
    }
    else
    {
        if(pcFlags.landChosenWither &amp;&amp; !pcFlags.witherFinished)
        {
            global.questionID=1; //Question ID - "Questions about the WITHER"
            createArbiterQuestion(3,"Who would choose to live there?","How do the people survive?","Why does the Dominion treat this place so poorly?");
        }
        else if(pcFlags.landChosenWither &amp;&amp; pcFlags.witherFinished)
        {
            global.questionID=0;
            createArbiterQuestion(3,"Witness the WITHER","Behold the SCOURGE","See the SCORCH");
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(thisBoxFont);
    
    

//draw_text(12,40,

    
//CENTERED
/*
for(nol = 0; nol&lt;lineCount+1; nol+=1)
{
    draw_set_color(col);
    draw_text(room_width/2-(string_width(line[nol])/2)+2,32+2+((string_height(line[nol])+16)*nol), line[nol]);
    
    lineDrawn=false;
    lineLength=string_length(line[nol]);
    charX=buffer;
    charIndex=1;
    realIndex=charIndex*nol;
    
    while(charIndex&lt;lineLength){   
        draw_set_color(col);
        draw_text(charX, 32+((string_height(line[nol])+16)*nol), string_char_at(line[nol], charIndex));
        charX+=string_width(string_char_at(line[nol], charIndex));
        charIndex++;
        }
}
*/

//LEFT
for(nol = 0; nol&lt;(lineCount+instaNewLineCount); nol++)
{
    //draw_set_color(c_olive);
    //draw_text(buffer+2,32+2+((string_height(line[nol])+16)*nol), line[nol]);
    lineDrawn=false;
    lineLength=string_length(line[nol]);
    charX=buffer;
    charIndex=1;
    
    while(charIndex&lt;lineLength){
    charIndex++;   
        draw_set_color(col);
        draw_text(charX, initHeight+((vSpace)*nol), string_char_at(line[nol], charIndex));
        charX+=string_width(string_char_at(line[nol], charIndex));
        curDrawChar=string_char_at(line[nol], charIndex);
        }
    
    
//    draw_text(buffer,32+((string_height(line[nol])+16)*nol), line[nol]);
}

if(done &amp;&amp; !choiceImpending)
{
    draw_sprite_ext(sprContinueText,image_index/4,room_width-48, room_height-80, 1, 1, 0, c_white, 1)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
